<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>GPS ë„ë³´ í…ŒìŠ¤í„° (Super Stable)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; touch-action: pan-x pan-y pinch-zoom; }
        .btn:active { transform: scale(0.97); }
        .map-canvas { background-color: #1a202c; touch-action: none; }
        .compass { 
            width: 60px; height: 60px; 
            border: 2px solid #10B981; border-radius: 50%; 
            position: relative; background: rgba(0,0,0,0.7);
        }
        .compass::before { 
            content: 'ğŸ“±'; position: absolute; 
            top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 16px;
        }
        .direction-arrow { 
            position: absolute; top: 50%; left: 50%; 
            width: 4px; height: 25px; background: #EF4444; border-radius: 2px;
            transform-origin: bottom center; transform: translate(-50%, -100%);
            z-index: 10;
        }
        .direction-arrow::before { 
            content: 'â–²'; position: absolute; top: -10px; left: 50%; 
            transform: translateX(-50%); color: #EF4444; font-size: 14px;
        }
        #reset-camera-btn { pointer-events: auto; }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center h-screen p-2 sm:p-4">

    <div class="w-full max-w-lg mx-auto flex flex-col h-full">
        <header class="text-center py-2">
            <h1 class="text-2xl font-bold text-cyan-400">GPS í…ŒìŠ¤í„° (Super Stable)</h1>
            <p id="app-status" class="text-gray-400 text-sm">GPS ì•ˆì •í™” ì¤‘...</p>
        </header>

        <div class="relative w-full flex-grow rounded-xl overflow-hidden border-2 border-cyan-500/30 my-2">
            <canvas id="mapCanvas" class="map-canvas"></canvas>
            
            <button id="reset-camera-btn" class="absolute top-2 left-1/2 -translate-x-1/2 bg-black/70 text-xs px-3 py-1 rounded-full border border-cyan-500/40">ğŸ“ ë‚´ ìœ„ì¹˜ë¡œ</button>
            
            <div class="absolute bottom-2 left-2 bg-black/50 p-2 rounded-lg text-xs leading-tight pointer-events-none">
                <p><span class="text-green-400">â—</span> ì´ë™ ì¤‘ (Live)</p>
                <p><span class="text-red-500">â—</span> ì •ì§€ (Locked)</p>
                <p><span class="text-yellow-400">â˜…</span> ìµœê³  ì‹ í˜¸</p>
            </div>
            
            <div class="absolute top-2 right-2 bg-black/50 p-2 rounded-full text-xs text-center font-sans pointer-events-none">
                <div class="font-bold text-red-400">N</div>
                <div>â¬†</div>
            </div>
            
            <div class="absolute bottom-2 right-2 bg-black/80 p-3 rounded-lg text-xs font-mono text-green-300 max-w-xs pointer-events-none">
                <div class="font-bold text-yellow-300 mb-1">GPS Status</div>
                <div id="debug-accuracy">ì •í™•ë„: -</div>
                <div id="debug-stationary">ì´ë™ ìƒíƒœ: -</div>
                <div id="debug-coords" class="text-[10px] text-gray-400">-</div>
            </div>
            
            <div class="absolute top-2 left-2 bg-black/50 p-2 rounded-lg">
                <div class="compass" id="compass">
                    <div class="direction-arrow" id="direction-arrow"></div>
                </div>
                <div class="text-xs text-center mt-1">
                    <div class="truncate">ëª©í‘œ ë°©ìœ„: <span id="bearing-display" class="text-cyan-400 font-bold">0Â°</span></div>
                    <div class="truncate">í˜„ì¬ ë°©ìœ„: <span id="phone-heading" class="text-green-400 font-bold">0Â°</span></div>
                    <div id="turn-guide" class="text-white font-bold mt-1 bg-gray-700 rounded px-1">ëŒ€ê¸° ì¤‘</div>
                </div>
            </div>
        </div>

        <div class="bg-gray-800 rounded-xl p-4 shadow-lg">
            <div class="grid grid-cols-2 sm:grid-cols-3 gap-2 text-sm mb-3">
                <div>ìƒíƒœ: <span id="state-display" class="font-mono text-yellow-300">IDLE</span></div>
                <div>ë‚¨ì€ ê±°ë¦¬: <span id="distance-display" class="font-mono font-bold text-green-400">0.0 m</span></div>
                <div>ìµœê³  ì‹ í˜¸: <span id="best-signal-display" class="font-mono text-yellow-400">-</span></div>
            </div>

            <div class="mb-3 p-2 bg-gray-700 rounded-lg">
                <label class="block text-xs font-medium text-cyan-300 mb-1">
                    GPS ì •ì§€ ê°ë„ (ë‚®ì„ìˆ˜ë¡ ë¯¼ê°): <span id="variance-threshold-value" class="font-mono text-white">0.30</span>
                </label>
                <input type="range" id="variance-threshold-slider" min="0.01" max="1.0" step="0.01" value="0.30" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-cyan-500"/>
            </div>

            <div id="control-section" class="hidden">
                <p id="rssi-prompt" class="text-green-300 font-bold text-center mb-2">ëª©í‘œ ë„ì°©! RSSI ì…ë ¥</p>
                <div class="flex gap-2">
                    <input type="number" id="rssi-input" class="flex-1 bg-gray-700 border border-gray-600 text-white text-xl font-bold rounded-lg p-2 text-center focus:ring-2 focus:ring-cyan-500" placeholder="-55">
                    <button id="submit-rssi-button" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg">ì…ë ¥ ì™„ë£Œ</button>
                </div>
            </div>
            
            <div id="log-section" class="hidden mt-2">
                 <button id="download-log-button" class="w-full bg-gray-600 hover:bg-gray-700 text-xs py-2 rounded text-gray-200">
                    ë¡œê·¸ ì €ì¥ (<span id="log-count">0</span>)
                </button>
            </div>
            
            <button id="start-button" class="w-full bg-blue-600 hover:bg-blue-700 font-bold py-3 rounded-lg text-lg mt-2 hidden">
                í…ŒìŠ¤íŠ¸ ì‹œì‘ (GPS ì¤€ë¹„ë¨)
            </button>
        </div>
    </div>

    <script>
        // ==========================================
        // 1. Math & Helper Functions
        // ==========================================
        const identityMatrix = (s) => Array.from({length:s},(_,i)=>{const r=Array(s).fill(0);r[i]=1;return r;});
        const multiplyMatrices = (A, B) => {
            const r=A.length, c=B[0].length, s=B.length;
            const res=Array.from({length:r},()=>Array(c).fill(0));
            for(let i=0;i<r;i++) for(let k=0;k<s;k++) for(let j=0;j<c;j++) res[i][j]+=A[i][k]*B[k][j];
            return res;
        };
        const transposeMatrix = (A) => A[0].map((_, c) => A.map(r => r[c]));
        const addMatrices = (A, B) => A.map((r, i) => r.map((v, j) => v + B[i][j]));
        const subtractMatrices = (A, B) => A.map((r, i) => r.map((v, j) => v - B[i][j]));
        const multiplyMatrixVector = (A, v) => A.map(r => r.reduce((s, val, i) => s + val * v[i], 0));
        const addVectors = (a, b) => a.map((v, i) => v + b[i]);
        const subtractVectors = (a, b) => a.map((v, i) => v - b[i]);
        const invert2x2 = (m) => {
            const det = m[0][0]*m[1][1] - m[0][1]*m[1][0];
            if(Math.abs(det)<1e-6) return identityMatrix(2);
            const invDet=1/det;
            return [[m[1][1]*invDet, -m[0][1]*invDet], [-m[1][0]*invDet, m[0][0]*invDet]];
        };

        // ==========================================
        // 2. Kalman Filter Class
        // ==========================================
        class KalmanFilter {
            constructor(q = 0.02) { 
                this.q = q; 
                this.R = [[15, 0], [0, 15]]; 
                this.reset();
            }
            reset() {
                this.x = [0, 0, 0, 0];
                this.P = identityMatrix(4).map(r => r.map(v => v * 1000));
                this.initialized = false;
                this.stationary = false;
            }
            setStationary(flag) { this.stationary = !!flag; }
            predict(dt) {
                if (!this.initialized || !dt || dt <= 0) return;
                const damping = this.stationary ? 0.05 : 0.8;
                const F = [[1,0,dt,0], [0,1,0,dt], [0,0,damping,0], [0,0,0,damping]];
                const Ft = transposeMatrix(F);
                this.x = multiplyMatrixVector(F, this.x);
                const newP = multiplyMatrices(multiplyMatrices(F, this.P), Ft);
                const pNoise = this.stationary ? this.q * 0.0001 : this.q; 
                const dt2 = dt * dt;
                const Q = [[pNoise*dt2,0,0,0], [0,pNoise*dt2,0,0], [0,0,pNoise,0], [0,0,0,pNoise]];
                this.P = addMatrices(newP, Q);
            }
            update(m) {
                if (!this.initialized) {
                    this.x = [m.x, m.y, 0, 0];
                    this.P = identityMatrix(4);
                    this.initialized = true;
                    return;
                }
                const H = [[1,0,0,0],[0,1,0,0]];
                const z = [m.x, m.y];
                const y = subtractVectors(z, multiplyMatrixVector(H, this.x));
                const PHt = multiplyMatrices(this.P, transposeMatrix(H));
                const S = addMatrices(multiplyMatrices(H, PHt), this.R);
                const K = multiplyMatrices(PHt, invert2x2(S));
                this.x = addVectors(this.x, multiplyMatrixVector(K, y));
                const KH = multiplyMatrices(K, H);
                this.P = multiplyMatrices(subtractMatrices(identityMatrix(4), KH), this.P);
                if (this.stationary) { this.x[2] = 0; this.x[3] = 0; }
            }
            getPosition() { return { x: this.x[0], y: this.x[1] }; }
            getVelocity() { return Math.hypot(this.x[2], this.x[3]); }
        }

        // ==========================================
        // 3. Main Application
        // ==========================================
        document.addEventListener('DOMContentLoaded', () => {
            // Elements
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const startBtn = document.getElementById('start-button');
            const appStatus = document.getElementById('app-status');
            
            const elState = document.getElementById('state-display');
            const elDist = document.getElementById('distance-display');
            const elSignal = document.getElementById('best-signal-display');
            const elHeading = document.getElementById('phone-heading');
            const elBearing = document.getElementById('bearing-display');
            const elTurn = document.getElementById('turn-guide');
            const arrow = document.getElementById('direction-arrow');
            
            const dbgAcc = document.getElementById('debug-accuracy');
            const dbgStat = document.getElementById('debug-stationary');
            const dbgCoords = document.getElementById('debug-coords');
            const slider = document.getElementById('variance-threshold-slider');
            const sliderVal = document.getElementById('variance-threshold-value');

            const ctrlSec = document.getElementById('control-section');
            const rssiIn = document.getElementById('rssi-input');
            const submitBtn = document.getElementById('submit-rssi-button');
            const logSec = document.getElementById('log-section');
            const logBtn = document.getElementById('download-log-button');
            const logCnt = document.getElementById('log-count');
            const resetCamBtn = document.getElementById('reset-camera-btn');

            // Configuration
            const EARTH_R = 6378137.0;
            const PARAMS = {
                ARRIVAL_DIST: 2.5,
                TARGET_RSSI: -40.0,
                STEPS: { FAR: 30.0, MID: 15.0, NEAR: 5.0 },
                RADII: { FAR: 20.0, MID: 10.0, NEAR: 5.0 },
            };
            
            // [ë³€ê²½] ì´ˆê¸°ê°’ì„ 0.3ìœ¼ë¡œ ë‘”ê°í•˜ê²Œ ì„¤ì • (ì†ë–¨ë¦¼ ë°©ì§€)
            let STAT_THRESH = 0.30; 
            const TARGET_SAMPLES = 20; 

            // State
            let algo, kalman = new KalmanFilter(0.02); 
            let origin = null;
            let lastPos = {x:0, y:0}; 
            let camera = { x: 0, y: 0, zoom: 25 };
            let isStationary = false;
            let isWaiting = false;
            let phoneHeading = 0;
            let logData = [];
            let originBuf = [];
            let accelBuf = [];
            let lastGpsTime = 0;
            let lastKalmanTime = null;
            let lastRawMeters = null;

            // [CORE] Helpers
            function project(lat, lon) {
                if (!origin) return {x:0, y:0};
                const x = (lon - origin.lon) * (EARTH_R * Math.cos(origin.lat * Math.PI / 180)) * (Math.PI / 180);
                const y = -1 * (lat - origin.lat) * EARTH_R * (Math.PI / 180); // North is -Y
                return {x, y};
            }

            function getBearing(from, to) {
                const dx = to.x - from.x;
                const dy = to.y - from.y; 
                let deg = (Math.atan2(dy, dx) * 180 / Math.PI) + 90;
                return (deg + 360) % 360;
            }

            // [CORE] Algorithm
            class Algorithm {
                constructor(start) {
                    this.pos = start; this.center = start; this.waypoint = start;
                    this.path = [start]; this.state = "INIT"; this.isFinished = false;
                    this.bestPos = start; this.bestSig = -100.0;
                    this.scanPts = []; this.scanRssi = {}; this.scanIdx = 0;
                    this.radius = PARAMS.RADII.FAR; this.step = PARAMS.STEPS.FAR;
                    this.dirs = [
                        {n:"N", dx:0, dy:-1}, {n:"S", dx:0, dy:1},
                        {n:"E", dx:1, dy:0}, {n:"W", dx:-1, dy:0}
                    ];
                }

                process(rssi) {
                    if(this.isFinished) return;
                    const avgRssi = rssi; 

                    if(avgRssi > this.bestSig) {
                        this.bestSig = avgRssi;
                        this.bestPos = {...this.pos};
                    }

                    if(avgRssi >= PARAMS.TARGET_RSSI) {
                        this.finish("SUCCESS");
                        return;
                    }

                    if (this.state === "INIT") {
                        this.setupScan(avgRssi);
                        this.state = "OUTBOUND";
                        this.waypoint = this.scanPts[0];
                    } 
                    else if (this.state === "OUTBOUND") {
                        const pid = this.getPtId(this.scanPts[this.scanIdx]);
                        this.scanRssi[pid] = avgRssi;
                        this.scanIdx++;
                        if(this.scanIdx < this.scanPts.length) {
                            this.waypoint = this.scanPts[this.scanIdx];
                        } else {
                            this.state = "INBOUND";
                            this.waypoint = this.center;
                        }
                    }
                    else if (this.state === "INBOUND") {
                        this.scanRssi['CENTER'] = avgRssi;
                        this.decide(avgRssi);
                    }
                    else if (this.state === "MOVING_CENTER") {
                        this.state = "INIT";
                        this.setupScan(avgRssi); 
                        this.state = "OUTBOUND";
                        this.waypoint = this.scanPts[0];
                    }
                }

                decide(centerRssi) {
                    let bestDir = null, maxRssi = -999;
                    for(let d of this.dirs) {
                        const key = `${d.n}_${this.radius}`;
                        const val = this.scanRssi[key] || -999;
                        if(val > maxRssi) { maxRssi = val; bestDir = d; }
                    }
                    if(bestDir && maxRssi > centerRssi + 1.0) {
                        this.center = { x: this.center.x + bestDir.dx*this.step, y: this.center.y + bestDir.dy*this.step };
                        this.state = "MOVING_CENTER";
                        this.waypoint = this.center;
                    } else {
                        if(this.radius === PARAMS.RADII.FAR) {
                            this.radius = PARAMS.RADII.MID; this.step = PARAMS.STEPS.MID;
                            this.state = "INIT"; this.setupScan(centerRssi);
                            this.state = "OUTBOUND"; this.waypoint = this.scanPts[0];
                        } else if (this.radius === PARAMS.RADII.MID) {
                            this.radius = PARAMS.RADII.NEAR; this.step = PARAMS.STEPS.NEAR;
                            this.state = "INIT"; this.setupScan(centerRssi);
                            this.state = "OUTBOUND"; this.waypoint = this.scanPts[0];
                        } else {
                            this.finish("FAIL_SHRINK");
                        }
                    }
                }

                setupScan(rssi) {
                    this.scanRssi = {}; this.scanIdx = 0;
                    this.scanPts = this.dirs.map(d => ({ x: this.center.x + d.dx*this.radius, y: this.center.y + d.dy*this.radius }));
                }

                getPtId(pt) {
                    const dx = pt.x - this.center.x; const dy = pt.y - this.center.y;
                    if(Math.abs(dx)<1 && dy < -1) return `N_${this.radius}`;
                    if(Math.abs(dx)<1 && dy > 1) return `S_${this.radius}`;
                    if(dx > 1 && Math.abs(dy)<1) return `E_${this.radius}`;
                    if(dx < -1 && Math.abs(dy)<1) return `W_${this.radius}`;
                    return "UNK";
                }

                finish(reason) { this.state = "FINISHED"; this.isFinished = true; }

                updatePos(p) {
                    if(!this.path.length) this.path.push(p);
                    const last = this.path[this.path.length-1];
                    if(Math.hypot(p.x-last.x, p.y-last.y) > 0.5) { this.pos = p; this.path.push(p); }
                    else { this.pos = p; }
                }
            }

            // --- UI ---
            function updateUI() {
                if(!algo || !lastPos) return;
                let status = algo.state;
                if(algo.state==="OUTBOUND") status = `ì™¸ê³½ íƒìƒ‰ ì¤‘ (${algo.scanIdx+1}/4)`;
                if(algo.state==="INBOUND") status = "ì¤‘ì‹¬ ë³µê·€ ì¤‘";
                if(algo.state==="FINISHED") status = "ì™„ë£Œ!";
                elState.textContent = status;
                const dist = Math.hypot(algo.waypoint.x - lastPos.x, algo.waypoint.y - lastPos.y);
                elDist.textContent = `${dist.toFixed(1)} m`;
                elSignal.textContent = algo.bestSig > -100 ? `${algo.bestSig.toFixed(1)} dBm` : '-';
                const targetBearing = getBearing(lastPos, algo.waypoint);
                elBearing.textContent = `${targetBearing.toFixed(0)}Â°`;
                let diff = targetBearing - phoneHeading;
                arrow.style.transform = `translate(-50%, -100%) rotate(${diff}deg)`;
                let guideDiff = diff;
                while(guideDiff <= -180) guideDiff += 360;
                while(guideDiff > 180) guideDiff -= 360;
                if(Math.abs(guideDiff) < 15) {
                    elTurn.textContent = "â¬† ì§ì§„"; elTurn.className = "text-white font-bold mt-1 bg-green-600 rounded px-2 py-1";
                } else {
                    const dir = guideDiff > 0 ? "ìš°íšŒì „" : "ì¢ŒíšŒì „";
                    elTurn.textContent = `${dir} ${Math.abs(guideDiff).toFixed(0)}Â°`;
                    elTurn.className = "text-white font-bold mt-1 bg-red-500 rounded px-2 py-1";
                }
            }

            function draw() {
                if(!origin) { requestAnimationFrame(draw); return; }
                const w = canvas.width, h = canvas.height;
                ctx.clearRect(0,0,w,h);
                ctx.save();
                ctx.translate(w/2, h/2);
                ctx.scale(camera.zoom, camera.zoom);
                ctx.translate(-camera.x, -camera.y);

                // Grid
                ctx.strokeStyle = "rgba(255,255,255,0.1)"; ctx.lineWidth = 1/camera.zoom;
                const gridSize = 10;
                const b = { l: camera.x - (w/2/camera.zoom), r: camera.x + (w/2/camera.zoom), t: camera.y - (h/2/camera.zoom), b: camera.y + (h/2/camera.zoom) };
                const startX = Math.floor(b.l/gridSize)*gridSize; const startY = Math.floor(b.t/gridSize)*gridSize;
                ctx.beginPath();
                for(let x=startX; x<b.r; x+=gridSize) { ctx.moveTo(x, b.t); ctx.lineTo(x, b.b); }
                for(let y=startY; y<b.b; y+=gridSize) { ctx.moveTo(b.l, y); ctx.lineTo(b.r, y); }
                ctx.stroke();

                if(algo) {
                    if(algo.path.length > 1) {
                        ctx.strokeStyle = "#6B7280"; ctx.lineWidth = 2/camera.zoom;
                        ctx.beginPath(); ctx.moveTo(algo.path[0].x, algo.path[0].y);
                        for(let i=1; i<algo.path.length; i++) ctx.lineTo(algo.path[i].x, algo.path[i].y);
                        ctx.stroke();
                    }
                    if(algo.center && !algo.isFinished) {
                        ctx.strokeStyle = "rgba(251, 191, 36, 0.4)"; ctx.lineWidth = 1/camera.zoom;
                        ctx.beginPath(); ctx.arc(algo.center.x, algo.center.y, algo.radius, 0, Math.PI*2); ctx.stroke();
                    }
                    ctx.fillStyle = "#EF4444"; ctx.beginPath(); ctx.arc(algo.waypoint.x, algo.waypoint.y, 0.6, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = "#EF4444"; ctx.lineWidth = 0.1; ctx.beginPath(); ctx.arc(algo.waypoint.x, algo.waypoint.y, PARAMS.ARRIVAL_DIST, 0, Math.PI*2); ctx.stroke();
                    if(algo.bestSig > -99) {
                        ctx.fillStyle = "#F59E0B"; ctx.font = `${10/camera.zoom}px sans-serif`;
                        ctx.fillText("â˜…", algo.bestPos.x, algo.bestPos.y);
                    }
                }
                
                // [ë³€ê²½] Me (ìƒíƒœì— ë”°ë¼ ìƒ‰ìƒ ë³€ê²½)
                // Locked = Red, Moving = Green
                ctx.fillStyle = isStationary ? "#EF4444" : "#10B981"; 
                ctx.beginPath(); ctx.arc(lastPos.x, lastPos.y, 0.6, 0, Math.PI*2); ctx.fill();
                
                // [ë³€ê²½] ê³ ì •ë¨ í‘œì‹œ ë§
                if(isStationary) {
                    ctx.strokeStyle = "#EF4444"; ctx.lineWidth = 0.1; 
                    ctx.beginPath(); ctx.arc(lastPos.x, lastPos.y, 1.0, 0, Math.PI*2); ctx.stroke();
                }

                ctx.restore();
                requestAnimationFrame(draw);
            }

            // --- Handlers ---
            function handleGps(pos) {
                const now = Date.now();
                if(now - lastGpsTime < 200) return; 
                lastGpsTime = now;
                const { latitude, longitude, accuracy } = pos.coords;

                // 1. Origin Setup
                if(!origin) {
                    if(accuracy > 50) {
                        appStatus.textContent = `ì‹ í˜¸ ì•½í•¨ (Â±${accuracy.toFixed(0)}m). ì•¼ì™¸ë¡œ ì´ë™í•˜ì„¸ìš”.`;
                        return;
                    }
                    originBuf.push({lat:latitude, lon:longitude});
                    appStatus.textContent = `GPS ì•ˆì •í™” ì¤‘... ${originBuf.length}/${TARGET_SAMPLES}`;
                    
                    if(originBuf.length >= TARGET_SAMPLES) {
                        const avgLat = originBuf.reduce((s,v)=>s+v.lat,0) / originBuf.length;
                        const avgLon = originBuf.reduce((s,v)=>s+v.lon,0) / originBuf.length;
                        origin = {lat: avgLat, lon: avgLon};
                        appStatus.textContent = "ì¤€ë¹„ ì™„ë£Œ. ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.";
                        startBtn.style.display = "block"; 
                        requestAnimationFrame(draw);
                    }
                    return;
                }

                // 2. Weak Signal Filter
                if(accuracy > 20) {
                    dbgAcc.textContent = `ì •í™•ë„: Â±${accuracy.toFixed(0)}m (ê±°ë¶€)`;
                    dbgAcc.className = "text-red-400";
                    return;
                }
                dbgAcc.textContent = `ì •í™•ë„: Â±${accuracy.toFixed(1)}m`;
                dbgAcc.className = "text-green-400";

                // 3. Project
                const raw = project(latitude, longitude);
                dbgCoords.textContent = `${raw.x.toFixed(1)}, ${raw.y.toFixed(1)}`;

                // [í•µì‹¬] ì™„ì „ ê³ ì • ë¡œì§ (Super Sticky)
                // ì •ì§€ ìƒíƒœ(Locked)ë¼ë©´, GPS ìœ„ì¹˜ë¥¼ ì—…ë°ì´íŠ¸í•˜ì§€ ì•ŠìŒ.
                // ë‹¨, ë„ˆë¬´ í¬ê²Œ íŠ„ ê²½ìš°(5m ì´ìƒ)ê°€ ì•„ë‹ˆë¼ë©´ ë¬´ì‹œ.
                if(isStationary) {
                    if(lastRawMeters) {
                        const jump = Math.hypot(raw.x - lastRawMeters.x, raw.y - lastRawMeters.y);
                        // 5m ì´ë‚´ì˜ ì›€ì§ì„ì€ ê·¸ëƒ¥ ë¬´ì‹œ (Locked)
                        if(jump < 5.0) {
                            return; 
                        }
                    }
                }
                lastRawMeters = raw;

                // 4. Kalman Update
                const dt = lastKalmanTime ? (now - lastKalmanTime)/1000 : 0;
                kalman.predict(dt);
                kalman.update(raw);
                lastKalmanTime = now;
                lastPos = kalman.getPosition();

                if(algo) algo.updatePos(lastPos);

                // 5. Check Arrival
                if(algo && !isWaiting && !algo.isFinished) {
                    const dist = Math.hypot(algo.waypoint.x - lastPos.x, algo.waypoint.y - lastPos.y);
                    if(dist < PARAMS.ARRIVAL_DIST) {
                        isWaiting = true;
                        if(navigator.vibrate) navigator.vibrate(200);
                        ctrlSec.classList.remove("hidden");
                        rssiIn.focus();
                        let msg = "ëª©í‘œ ë„ì°©!";
                        if(algo.state === "OUTBOUND") msg = "ìŠ¤ìº” ì§€ì  ë„ì°©! RSSI ì…ë ¥";
                        if(algo.state === "INBOUND") msg = "ì¤‘ì‹¬ ë³µê·€! RSSI ì…ë ¥";
                        document.getElementById('rssi-prompt').textContent = msg;
                    }
                }
                updateUI();
            }

            function handleOrientation(e) {
                if(e.webkitCompassHeading !== undefined && e.webkitCompassHeading !== null) {
                    phoneHeading = e.webkitCompassHeading;
                } else if(e.alpha !== null) {
                    phoneHeading = (360 - e.alpha) % 360; 
                }
                elHeading.textContent = `${phoneHeading.toFixed(0)}Â°`;
                updateUI();
            }

            function handleMotion(e) {
                const a = e.acceleration || e.accelerationIncludingGravity;
                if(!a) return;
                const mag = Math.hypot(a.x||0, a.y||0, a.z||0);
                accelBuf.push({t:Date.now(), v:mag});
                while(accelBuf.length && Date.now()-accelBuf[0].t > 1500) accelBuf.shift();
                if(accelBuf.length > 5) {
                    const avg = accelBuf.reduce((s,i)=>s+i.v,0)/accelBuf.length;
                    const variance = accelBuf.reduce((s,i)=>s+Math.pow(i.v-avg,2),0)/accelBuf.length;
                    
                    isStationary = variance < STAT_THRESH;
                    kalman.setStationary(isStationary);
                    
                    // UI ì—…ë°ì´íŠ¸
                    dbgStat.textContent = isStationary ? "ì •ì§€ (Locked)" : "ì´ë™ ì¤‘";
                    dbgStat.className = isStationary ? "text-red-500 font-bold" : "text-green-400";
                }
            }

            // --- Init ---
            const setupCanvas = () => {
                canvas.width = canvas.parentElement.clientWidth;
                canvas.height = canvas.parentElement.clientHeight;
            };
            window.addEventListener('resize', setupCanvas);
            setupCanvas();

            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(handleGps, 
                    (err) => { console.error(err); appStatus.textContent = "GPS ì˜¤ë¥˜: " + err.message; }, 
                    { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 }
                );
            } else {
                appStatus.textContent = "GPS ë¯¸ì§€ì› ë¸Œë¼ìš°ì €";
            }

            startBtn.addEventListener('click', async () => {
                if(!origin) return;
                algo = new Algorithm({x:0, y:0});
                kalman.reset(); lastPos = {x:0, y:0};
                lastKalmanTime = null; logData = [];
                
                startBtn.style.display = "none";
                logSec.classList.remove("hidden");
                
                if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
                    try { await DeviceOrientationEvent.requestPermission(); } catch(e){ console.warn(e); }
                }
                window.addEventListener('deviceorientation', handleOrientation);

                if (typeof DeviceMotionEvent?.requestPermission === 'function') {
                    try { await DeviceMotionEvent.requestPermission(); } catch(e){ console.warn(e); }
                }
                window.addEventListener('devicemotion', handleMotion, {passive:true});

                isWaiting = true;
                ctrlSec.classList.remove("hidden");
                document.getElementById('rssi-prompt').textContent = "ì‹œì‘ì (ì¤‘ì‹¬) RSSI ì…ë ¥";
            });

            submitBtn.addEventListener('click', () => {
                const val = parseFloat(rssiIn.value);
                if(isNaN(val)) { alert("ê°’ì„ ì…ë ¥í•˜ì„¸ìš”"); return; }
                logData.push({
                    time: new Date().toISOString(), rssi: val, state: algo.state,
                    pos: {...algo.pos}, target: {...algo.waypoint}, best: algo.bestSig
                });
                logCnt.textContent = logData.length;
                algo.process(val);
                rssiIn.value = "";
                ctrlSec.classList.add("hidden");
                isWaiting = false;
                if(algo.isFinished) alert("íƒìƒ‰ ì¢…ë£Œ! RSSI ë§Œì¡± (-40dBm ì´ìƒ)");
                else appStatus.textContent = "ë‹¤ìŒ ëª©í‘œë¡œ ì´ë™í•˜ì„¸ìš”.";
                updateUI();
            });

            // Touch
            let touchState = { d:0, z:25, pan:false, start:{x:0,y:0}, cam:{x:0,y:0} };
            canvas.addEventListener('touchstart', e => {
                if(e.touches.length===1) { touchState.pan=true; touchState.start={x:e.touches[0].clientX, y:e.touches[0].clientY}; touchState.cam={...camera}; }
                else if(e.touches.length===2) { touchState.pan=false; touchState.d = Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY); touchState.z = camera.zoom; }
            }, {passive:false});
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                if(e.touches.length===1 && touchState.pan) {
                    const dx = (e.touches[0].clientX - touchState.start.x)/camera.zoom;
                    const dy = (e.touches[0].clientY - touchState.start.y)/camera.zoom;
                    camera.x = touchState.cam.x - dx; camera.y = touchState.cam.y - dy;
                } else if(e.touches.length===2) {
                    const d = Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
                    camera.zoom = Math.max(5, Math.min(100, touchState.z * (d/touchState.d)));
                }
            }, {passive:false});
            resetCamBtn.addEventListener('click', () => { if(lastPos) { camera.x = lastPos.x; camera.y = lastPos.y; camera.zoom = 25; } });
            logBtn.addEventListener('click', () => {
                const blob = new Blob([JSON.stringify(logData, null, 2)], {type:'application/json'});
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'walk_test_log.json'; a.click();
            });
            slider.addEventListener('input', e => { STAT_THRESH = parseFloat(e.target.value); sliderVal.textContent = STAT_THRESH; });
        });
    </script>
</body>
</html>