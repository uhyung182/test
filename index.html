<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>GPS 테스터 (Raw Absolute)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; touch-action: none; }
        .map-canvas { background-color: #1a202c; touch-action: none; }
        .compass { 
            width: 60px; height: 60px; 
            border: 2px solid #10B981; border-radius: 50%; 
            position: relative; background: rgba(0,0,0,0.7);
        }
        .direction-arrow { 
            position: absolute; top: 50%; left: 50%; 
            width: 4px; height: 25px; background: #EF4444; 
            transform-origin: bottom center; transform: translate(-50%, -100%);
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col h-screen p-4">

    <header class="text-center mb-2">
        <h1 class="text-xl font-bold text-cyan-400">GPS Raw (Absolute)</h1>
        <p id="status" class="text-xs text-gray-400">GPS 대기 중...</p>
    </header>

    <div class="relative flex-grow rounded-xl overflow-hidden border-2 border-gray-700 mb-4">
        <canvas id="mapCanvas" class="map-canvas"></canvas>
        
        <div class="absolute top-2 left-2 bg-black/60 p-2 rounded text-xs">
            <div class="compass mb-2"><div id="arrow" class="direction-arrow"></div></div>
            <div>목표: <span id="bearing" class="text-cyan-300">0°</span></div>
            <div>나: <span id="heading" class="text-green-300">0°</span></div>
        </div>
        <div class="absolute bottom-2 right-2 bg-black/60 p-2 rounded text-xs text-right">
            <div id="gps-lat">Lat: -</div>
            <div id="gps-lon">Lon: -</div>
            <div id="gps-acc" class="text-yellow-300">Acc: -</div>
        </div>
    </div>

    <div class="bg-gray-800 p-4 rounded-xl space-y-3">
        <div class="flex justify-between text-sm">
            <span>상태: <b id="algo-state" class="text-yellow-300">IDLE</b></span>
            <span>거리: <b id="target-dist" class="text-green-400">0.0m</b></span>
        </div>
        
        <div id="input-area" class="hidden">
            <p class="text-center text-sm mb-2 text-green-300 font-bold" id="msg">RSSI 입력</p>
            <div class="flex gap-2">
                <input type="number" id="rssi-in" class="flex-1 bg-gray-700 p-2 rounded text-center text-white" placeholder="-55">
                <button id="btn-submit" class="bg-blue-600 px-4 rounded font-bold">입력</button>
            </div>
        </div>
        
        <button id="btn-start" class="w-full bg-green-600 py-3 rounded font-bold hidden">테스트 시작</button>
    </div>

    <script>
        // --- Constants ---
        const PARAMS = {
            ARRIVAL_DIST: 6.0,    // 6m 이내 도착
            TARGET_RSSI: -55.0,   // 목표 신호
            DEAD_ZONE: -80.0,     // 탐색 제외
            // 이동 거리 (미터 단위)
            STEP: { FAR: 30, MID: 15, NEAR: 5 },
            SCAN: { FAR: 30, MID: 15, NEAR: 8 }
        };

        // --- Globals ---
        let myPos = null;   // {lat, lon}
        let targetPos = null; // {lat, lon}
        let centerPos = null; // {lat, lon} 베이스캠프
        let phoneHeading = 0;
        
        let algoState = "IDLE";
        let scanQueue = [];
        let scanRssi = {};
        
        // Greedy Logic Variables
        let prevBestRssi = -999;
        let lastDirName = null;
        let skipDir = null;
        let failRssi = null; 
        let failDir = null;

        // Map View
        const ZOOM_LEVEL = 18; // 기본 줌 (미터/픽셀 변환용)
        let pixelsPerMeter = 2.5; // 화면 배율

        // --- Utils ---
        // Haversine: 두 좌표 사이 거리 (m)
        function getDist(p1, p2) {
            if(!p1 || !p2) return 0;
            const R = 6371e3;
            const φ1 = p1.lat * Math.PI/180, φ2 = p2.lat * Math.PI/180;
            const Δφ = (p2.lat-p1.lat) * Math.PI/180;
            const Δλ = (p2.lon-p1.lon) * Math.PI/180;
            const a = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2) * Math.sin(Δλ/2)**2;
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        // Bearing: 두 좌표 사이 방위각 (0~360)
        function getBearing(p1, p2) {
            if(!p1 || !p2) return 0;
            const y = Math.sin(p2.lon*Math.PI/180 - p1.lon*Math.PI/180) * Math.cos(p2.lat*Math.PI/180);
            const x = Math.cos(p1.lat*Math.PI/180)*Math.sin(p2.lat*Math.PI/180) -
                      Math.sin(p1.lat*Math.PI/180)*Math.cos(p2.lat*Math.PI/180)*Math.cos(p2.lon*Math.PI/180 - p1.lon*Math.PI/180);
            return (Math.atan2(y, x) * 180/Math.PI + 360) % 360;
        }

        // Move: 특정 방위(bearing)로 거리(dist)만큼 이동한 새 좌표
        function moveCoord(start, bearing, dist) {
            const R = 6371e3;
            const δ = dist / R;
            const θ = bearing * Math.PI/180;
            const φ1 = start.lat * Math.PI/180;
            const λ1 = start.lon * Math.PI/180;
            const φ2 = Math.asin(Math.sin(φ1)*Math.cos(δ) + Math.cos(φ1)*Math.sin(δ)*Math.cos(θ));
            const λ2 = λ1 + Math.atan2(Math.sin(θ)*Math.sin(δ)*Math.cos(φ1), Math.cos(δ)-Math.sin(φ1)*Math.sin(φ2));
            return { lat: φ2 * 180/Math.PI, lon: λ2 * 180/Math.PI };
        }

        // Directions (Bearing)
        const DIRS = {
            'up': 0, 'right': 90, 'down': 180, 'left': 270
        };

        // --- App Logic ---
        const cvs = document.getElementById('mapCanvas');
        const ctx = cvs.getContext('2d');
        
        // Resize
        const resize = () => { cvs.width = cvs.parentElement.clientWidth; cvs.height = cvs.parentElement.clientHeight; };
        window.addEventListener('resize', resize); resize();

        // GPS Handler
        navigator.geolocation.watchPosition(
            pos => {
                const { latitude, longitude, accuracy } = pos.coords;
                myPos = { lat: latitude, lon: longitude };
                
                document.getElementById('gps-lat').innerText = `Lat: ${latitude.toFixed(5)}`;
                document.getElementById('gps-lon').innerText = `Lon: ${longitude.toFixed(5)}`;
                document.getElementById('gps-acc').innerText = `Acc: ±${accuracy.toFixed(1)}m`;
                
                // 시작 버튼 활성화 (최초 1회)
                document.getElementById('btn-start').classList.remove('hidden');
                document.getElementById('status').innerText = "GPS 수신 중";

                // 도착 체크
                if (targetPos && algoState !== "IDLE") {
                    const d = getDist(myPos, targetPos);
                    document.getElementById('target-dist').innerText = d.toFixed(1) + "m";
                    
                    if (d < PARAMS.ARRIVAL_DIST) {
                        // 도착!
                        document.getElementById('input-area').classList.remove('hidden');
                        document.getElementById('msg').innerText = "도착! RSSI 입력";
                        if(navigator.vibrate) navigator.vibrate(200);
                    }
                }
                draw();
            },
            err => alert("GPS Error: " + err.message),
            { enableHighAccuracy: true, maximumAge: 0 }
        );

        // Orientation
        window.addEventListener('deviceorientation', e => {
            if(e.webkitCompassHeading) phoneHeading = e.webkitCompassHeading;
            else if(e.alpha) phoneHeading = (360 - e.alpha) % 360;
            document.getElementById('heading').innerText = phoneHeading.toFixed(0) + "°";
            draw();
        });

        // Draw Map
        function draw() {
            if (!myPos) return;
            ctx.clearRect(0, 0, cvs.width, cvs.height);
            
            const cx = cvs.width / 2;
            const cy = cvs.height / 2;

            // Grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(cx, 0); ctx.lineTo(cx, cvs.height);
            ctx.moveTo(0, cy); ctx.lineTo(cvs.width, cy);
            ctx.stroke();

            // Target
            if (targetPos) {
                // 내 위치(myPos)가 항상 화면 중앙(cx, cy)임.
                // 타겟의 상대 위치 계산 (미터 단위 -> 픽셀 변환)
                const d = getDist(myPos, targetPos);
                const b = getBearing(myPos, targetPos);
                
                // 화면상 좌표 (북쪽이 위)
                // bearing 0(N) -> dy -, dx 0
                // bearing 90(E) -> dy 0, dx +
                const rad = (b - 90) * Math.PI / 180; // Canvas는 0도가 3시 방향이라 보정
                const tx = cx + Math.cos(rad) * d * pixelsPerMeter; // 90도 회전? 아니, bearing 그대로 씀
                
                // Bearing to XY:
                // 0 deg (Up) -> x=0, y=-d
                // 90 deg (Right) -> x=d, y=0
                const bx = Math.sin(b * Math.PI/180) * d * pixelsPerMeter;
                const by = -Math.cos(b * Math.PI/180) * d * pixelsPerMeter;

                ctx.fillStyle = 'red';
                ctx.beginPath(); 
                ctx.arc(cx + bx, cy + by, 8, 0, Math.PI*2); 
                ctx.fill();
                
                // Arrival Zone
                ctx.strokeStyle = 'red';
                ctx.beginPath();
                ctx.arc(cx + bx, cy + by, PARAMS.ARRIVAL_DIST * pixelsPerMeter, 0, Math.PI*2);
                ctx.stroke();

                // Update Compass UI
                const targetB = getBearing(myPos, targetPos);
                document.getElementById('bearing').innerText = targetB.toFixed(0) + "°";
                const arrowDeg = targetB - phoneHeading;
                document.getElementById('arrow').style.transform = `translate(-50%, -100%) rotate(${arrowDeg}deg)`;
            }

            // Me (Always Center)
            ctx.fillStyle = '#10B981';
            ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI*2); ctx.fill();
        }

        // --- Algorithm (Ver3 Logic) ---
        const processAlgo = (rssi) => {
            if (rssi >= PARAMS.TARGET_RSSI) {
                alert("탐색 성공! (-55dBm 도달)");
                algoState = "FINISHED";
                return;
            }

            // 1. INIT
            if (algoState === "INIT") {
                if (rssi < PARAMS.DEAD_ZONE) { alert("신호 너무 약함"); return; }
                
                centerPos = { ...myPos };
                prevBestRssi = rssi;
                scanRssi = {};
                
                // Adaptive Radius
                let r = PARAMS.SCAN.FAR;
                if(rssi > -65) r = PARAMS.SCAN.NEAR;
                else if(rssi > -75) r = PARAMS.SCAN.MID;

                // Queue: Up, Right, Down, Left
                const order = ['up', 'right', 'down', 'left'];
                scanQueue = order.filter(d => d !== skipDir && d !== failDir);
                
                // Reuse failed data if exists
                if(failDir) scanRssi[failDir] = failRssi;
                failDir = null;

                if(scanQueue.length > 0) {
                    const nextDir = scanQueue[0];
                    targetPos = moveCoord(centerPos, DIRS[nextDir], r);
                    algoState = "SCANNING";
                } else decide();
            }
            
            // 2. SCANNING
            else if (algoState === "SCANNING") {
                const done = scanQueue.shift();
                scanRssi[done] = rssi;
                
                if (scanQueue.length > 0) {
                    const next = scanQueue[0];
                    // 반경 재계산 필요 없음 (같은 중심)
                    let r = PARAMS.SCAN.FAR; // Simple fallback
                    if(prevBestRssi > -65) r = PARAMS.SCAN.NEAR;
                    else if(prevBestRssi > -75) r = PARAMS.SCAN.MID;

                    targetPos = moveCoord(centerPos, DIRS[next], r);
                } else {
                    decide();
                }
            }

            // 3. MOVING (Greedy)
            else if (algoState === "MOVING") {
                // Check if improved
                if (rssi >= prevBestRssi - 1.0) {
                    // Good! Keep going
                    prevBestRssi = rssi;
                    centerPos = { ...myPos }; // Update Base
                    
                    let step = PARAMS.STEP.FAR;
                    if(rssi > -65) step = PARAMS.STEP.NEAR;
                    else if(rssi > -75) step = PARAMS.STEP.MID;

                    targetPos = moveCoord(centerPos, DIRS[lastDirName], step * 1.2);
                } else {
                    // Bad! Backtrack
                    failRssi = rssi;
                    failDir = lastDirName;
                    targetPos = { ...centerPos }; // Go back
                    algoState = "BACKTRACK";
                }
            }

            // 4. BACKTRACK
            else if (algoState === "BACKTRACK") {
                // Arrived back at center. Restart Scan.
                algoState = "INIT";
                skipDir = null; 
                processAlgo(rssi); // Recursion with current(center) rssi
            }

            document.getElementById('algo-state').innerText = algoState;
            draw();
        };

        function decide() {
            let bestDir = null, max = -999;
            for(let d in scanRssi) {
                if(scanRssi[d] > PARAMS.DEAD_ZONE && scanRssi[d] > max) {
                    max = scanRssi[d]; bestDir = d;
                }
            }
            
            if (!bestDir) { alert("모든 방향 신호 없음. 이동 불가."); return; }

            let step = PARAMS.STEP.FAR;
            if(max > -65) step = PARAMS.STEP.NEAR;
            else if(max > -75) step = PARAMS.STEP.MID;

            targetPos = moveCoord(centerPos, DIRS[bestDir], step);
            lastDirName = bestDir;
            
            // Set Skip (Opposite)
            if(bestDir=='up') skipDir='down';
            if(bestDir=='down') skipDir='up';
            if(bestDir=='left') skipDir='right';
            if(bestDir=='right') skipDir='left';

            algoState = "MOVING";
        }

        // --- Inputs ---
        document.getElementById('btn-start').onclick = () => {
            if(!myPos) return;
            document.getElementById('btn-start').classList.add('hidden');
            document.getElementById('input-area').classList.remove('hidden');
            document.getElementById('msg').innerText = "시작점 RSSI 입력";
            algoState = "INIT";
            document.getElementById('algo-state').innerText = algoState;
            
            // iOS Permission
            if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission();
            }
        };

        document.getElementById('btn-submit').onclick = () => {
            const val = parseFloat(document.getElementById('rssi-in').value);
            if(!val) return;
            document.getElementById('input-area').classList.add('hidden');
            document.getElementById('rssi-in').value = '';
            processAlgo(val);
        };
    </script>
</body>
</html>